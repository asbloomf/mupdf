import org.apache.tools.ant.taskdefs.condition.Os

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.3.0'
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

apply plugin: 'com.android.application'

dependencies {
    compile fileTree(dir: 'libs', include: '*.so')
}

android {

    compileSdkVersion 17
    buildToolsVersion "23.0.1"

    /*  this stops gradle from making it's own Android.mk file */
	sourceSets.main.jni.srcDirs = []
   
    sourceSets {
        main {
            manifest {
                srcFile 'AndroidManifest.xml'
            }
            java {
                srcDir 'src'
            }
            res {
                srcDir 'res'
            }
            assets {
                srcDir 'assets'
            }
            resources {
                srcDir 'src'
            }
            jniLibs {
            	srcDir 'libs'
            }
        }

        // Move the build types to build-types/<type>
        // For instance, build-types/debug/java, build-types/debug/AndroidManifest.xml, ...
        // This moves them out of them default location under src/<type>/... which would
        // conflict with src/ being used by the main source set.
        // Adding new build types or product flavors should be accompanied
        // by a similar customization.
        debug.setRoot('build-types/debug')
        release.setRoot('build-types/release')
    }


    defaultConfig {
      minSdkVersion 9
      targetSdkVersion 16
      versionCode 3
      versionName "@string/version"

      ndk {
        moduleName "mupdf"
      }
    }

    /* This is important, it will run lint checks but won't abort build */
    lintOptions {
        abortOnError false
    }

    splits {
        abi {
            enable true // enable ABI split feature to create one APK per ABI
            //universalApk true //generate an additional APK that targets all the ABIs
        }
    }
    // map for the version code
    project.ext.versionCodes = ['armeabi':1, 'armeabi-v7a':2, 'arm64-v8a':3, 'mips':5, 'mips64':6, 'x86':8, 'x86_64':9]

    android.applicationVariants.all { variant ->
        // assign different version code for each output
        variant.outputs.each { output ->
            output.versionCodeOverride =
                    project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode
        }
    }

/*  This defines the path to Android's ndk-build.  */
def ndkBuildPath = plugins.getPlugin('com.android.application').sdkHandler.getNdkFolder().absolutePath + File.separator + 'ndk-build'
if (Os.isFamily(Os.FAMILY_WINDOWS)) {
    ndkBuildPath +='.cmd'
}

/*  This task builds the native part  */
task buildNative(type: Exec,description: 'Compile JNI source via NDK') {
    println('executing buildNative')
    commandLine ndkBuildPath, '-C', file('.').absolutePath//, ' SUPPORT_GPROOF=1'
    //'NDK_PROJECT_PATH=build','APP_BUILD_SCRIPT=src/main/jni/Android.mk'//force using appropriate Makefile
}

/*  This task cleans the native part  */
task cleanNative(type: Exec, description: 'Clean JNI object files') {
    println('executing cleanNative')
    commandLine ndkBuildPath, '-C', file('.').absolutePath, 'clean'
}

/*  cleaning should also include cleaning native  */
clean.dependsOn 'cleanNative'

/*  building should include native  */
tasks.withType(JavaCompile){
    compileTask -> compileTask.dependsOn buildNative
}

    signingConfigs {
        release {
            storeFile file("C:\\src\\my-release-key.keystore")
            storePassword "ducinaltum"
            keyAlias "alias"
            keyPassword "ducinaltum"
        }
    }

    buildTypes {
        release {
            //minifyEnabled true
            shrinkResources true
            //proguardFiles getDefaultProguardFile('proguard-android-optimize.txt')
            signingConfig signingConfigs.release
        }
        debug {
            jniDebuggable true
        }
    }
}
